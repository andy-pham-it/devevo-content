[
  {
    "id": "rn-1",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which component is used to render a high-performance scrolling list in React Native?",
    "codeSnippet": null,
    "options": [
      "ScrollView",
      "ListView",
      "FlatList",
      "RecyclerView"
    ],
    "correctAnswerIndex": 2,
    "explanation": "FlatList is an optimized component for rendering large lists of data. It only renders items that are currently visible on the screen (lazy rendering), drastically improving performance."
  },
  {
    "id": "rn-2",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which Hook is commonly used to create animations in React Native (using the Animated library)?",
    "codeSnippet": null,
    "options": [
      "useAnim",
      "useRef",
      "useAnimation",
      "useTransition"
    ],
    "correctAnswerIndex": 1,
    "explanation": "An Animated.Value is typically initialized using the useRef hook (e.g., useRef(new Animated.Value(0)).current) to preserve the reference value across component re-renders."
  },
  {
    "id": "rn-3",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What is the default flexDirection for Flexbox in React Native?",
    "codeSnippet": null,
    "options": [
      "row",
      "column",
      "row-reverse",
      "column-reverse"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Unlike the web (where the default is 'row'), React Native defaults its flexDirection to 'column' to better accommodate the vertical layouts standard to mobile devices."
  },
  {
    "id": "rn-4",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which of the following is NOT a valid method for styling components in React Native?",
    "codeSnippet": null,
    "options": [
      "StyleSheet.create",
      "Inline styles",
      "CSS file import (style.css)",
      "Styled Components"
    ],
    "correctAnswerIndex": 2,
    "explanation": "React Native does not natively support traditional CSS file imports. You must use JavaScript objects via StyleSheet, inline styles, or third-party libraries like Styled Components/NativeWind."
  },
  {
    "id": "rn-5",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which core component is used to capture text input from the user?",
    "codeSnippet": null,
    "options": [
      "Input",
      "TextField",
      "TextInput",
      "EditText"
    ],
    "correctAnswerIndex": 2,
    "explanation": "TextInput is the fundamental core component used for capturing keyboard text inputs from users within React Native applications."
  },
  {
    "id": "rn-6",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What is the most popular standard library used for handling navigation in React Native?",
    "codeSnippet": null,
    "options": [
      "React Router",
      "React Navigation",
      "Native Navigation",
      "Expo Router"
    ],
    "correctAnswerIndex": 1,
    "explanation": "React Navigation (and subsequently Expo Router which is built upon it) is the most widely adopted and recommended community solution for handling screen routing and navigation."
  },
  {
    "id": "rn-7",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What does React Native's New Architecture use to replace the old Bridge mechanism?",
    "codeSnippet": null,
    "options": [
      "JSI (JavaScript Interface)",
      "TurboModules",
      "Fabric",
      "Hermes"
    ],
    "correctAnswerIndex": 0,
    "explanation": "The JSI (JavaScript Interface) allows JavaScript to directly invoke C++ objects synchronously without needing to serialize messages into JSON over a bridge, massively boosting performance."
  },
  {
    "id": "rn-8",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What is Hermes in the React Native ecosystem?",
    "codeSnippet": null,
    "options": [
      "A UI component library",
      "An optimized JavaScript Engine for Mobile",
      "A powerful Debugger tool",
      "An automated build tool"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Hermes is an open-source JavaScript engine optimized directly for React Native deployments. It significantly decreases app startup time, APK size, and overall memory footprint."
  },
  {
    "id": "rn-9",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "How can you optimize performance when rendering a long list containing large images?",
    "codeSnippet": null,
    "options": [
      "Serve images in 4K resolution",
      "Render all images simultaneously",
      "Utilize resizeMode='center'",
      "Implement getItemLayout and efficiently resize images"
    ],
    "correctAnswerIndex": 3,
    "explanation": "Implementing getItemLayout allows FlatList to bypass calculating dimensions dynamically, improving rendering speed. Properly resizing images to match their display frames minimizes costly memory consumption."
  },
  {
    "id": "rn-10",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which component is used to ensure content renders securely within the device's viewable boundaries, avoiding notches or home indicators?",
    "codeSnippet": null,
    "options": [
      "View",
      "SafeAreaView",
      "KeyboardAvoidingView",
      "ScrollView"
    ],
    "correctAnswerIndex": 1,
    "explanation": "SafeAreaView (especially from react-native-safe-area-context) automatically applies necessary padding to prevent application content from being obscured by hardware elements like the notch or home bar."
  },
  {
    "id": "rn-11",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What primary feature does 'Fast Refresh' provide in React Native?",
    "codeSnippet": null,
    "options": [
      "Forces a complete hard reload of the entire app upon any code change",
      "Updates the code instantly while preserving the current component state (HMR)",
      "Boosts the UI frame rate strictly universally to 120fps",
      "Flushes and clears all local memory caches"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Fast Refresh unifies Hot Reloading into a reliable system that immediately injects new JS code changes into the running app without losing its current local state."
  },
  {
    "id": "rn-12",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What is the primary function of Platform.select()?",
    "codeSnippet": null,
    "options": [
      "Downgrading the React Native version dynamically",
      "Executing platform-specific conditional code natively (for iOS or Android)",
      "Targeting and selecting a physical device for remote debugging",
      "Validating the current active network connection speed"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Platform.select({ ios: ..., android: ... }) conveniently allows developers to return distinct values, styles, or logic strictly depending on the operational platform the application is currently running within."
  },
  {
    "id": "rn-13",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Within the legacy React Native Architecture, what task does the Shadow thread natively handle?",
    "codeSnippet": null,
    "options": [
      "Compiling the dynamic JavaScript codebase",
      "Calculating Layout geometry and positions (using the Yoga engine)",
      "Painting pixels visually onto the screen directly",
      "Processing asynchronous network requests"
    ],
    "correctAnswerIndex": 1,
    "explanation": "The Shadow thread is explicitly responsible for computing the Flexbox layout math via the Yoga engine before officially transmitting dimensions down to the native UI thread explicitly for painting."
  },
  {
    "id": "rn-14",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which library is heavily utilized for executing complex, high-performance animations directly on the UI thread?",
    "codeSnippet": null,
    "options": [
      "React Native Animated",
      "React Spring",
      "React Native Reanimated",
      "Lottie"
    ],
    "correctAnswerIndex": 2,
    "explanation": "React Native Reanimated is the modern standard for writing complex 60-120fps animations by declaring UI operations as 'worklets' that execute synchronously and exclusively on the Native UI thread."
  },
  {
    "id": "rn-15",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What is the crucial role of the 'key' prop when rendering lists of components?",
    "codeSnippet": null,
    "options": [
      "To suppress console warnings",
      "To provide a unique identifier that helps React optimize the diffing algorithm and reduce unnecessary re-renders",
      "It has no functional necessity",
      "To dictate alphabetical sorting orders"
    ],
    "correctAnswerIndex": 1,
    "explanation": "Keys help React identify which exact items have changed, been added, or been removed, allowing it to bypass unnecessary computational UI tree re-renders."
  },
  {
    "id": "rn-16",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which core API is primarily leveraged to interface with custom Native Modules?",
    "codeSnippet": null,
    "options": [
      "NativeModules",
      "DeviceEventEmitter",
      "Linking",
      "AppState"
    ],
    "correctAnswerIndex": 0,
    "explanation": "The NativeModules object actively exposes bridged Objective-C, Swift, Java, or Kotlin logic methods to JavaScript."
  },
  {
    "id": "rn-17",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What exact physical layout issue does KeyboardAvoidingView resolve?",
    "codeSnippet": null,
    "options": [
      "Automatically dismissing active keyboards when users touch the background",
      "Preventing the software keyboard from blocking actively focused interactive screen inputs",
      "Dynamically mutating the hardware keypad aesthetics",
      "Systematically disabling native keyboards"
    ],
    "correctAnswerIndex": 1,
    "explanation": "A KeyboardAvoidingView structurally alters dynamically nested native heights, positions, or bottom padding to ensure actively focused inputs remain completely visible."
  },
  {
    "id": "rn-18",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Which CLI command explicitly instantiates a pure bare-workflow React Native codebase without Expo?",
    "codeSnippet": null,
    "options": [
      "npx create-react-app",
      "npx react-native init",
      "npm install react-native",
      "expo init"
    ],
    "correctAnswerIndex": 1,
    "explanation": "The command 'npx react-native init <ProjectName>' functionally bootstraps a generic bare React Native CLI template."
  },
  {
    "id": "rn-19",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "What distinct strategic capability do Over-the-Air (OTA) updates, utilizing solutions like CodePush, empower?",
    "codeSnippet": null,
    "options": [
      "Updating native binary code without App Store reviews",
      "Updating the JavaScript payload or assets flawlessly, bypassing App Store bundle reviews",
      "Forcing entirely complete faster runtime initial loading uniformly",
      "Remote network debugger logging dynamically"
    ],
    "correctAnswerIndex": 1,
    "explanation": "OTA updates distribute JavaScript application bundles or asset updates to devices, bypassing app store review delays, provided native code (Objective-C/Java) doesn't change."
  },
  {
    "id": "rn-20",
    "category": "mobile",
    "topic": "react-native",
    "level": "junior",
    "questionText": "Under what condition should React.memo() be exclusively used?",
    "codeSnippet": null,
    "options": [
      "Always use it for every single component",
      "When a component render is computationally expensive and its props rarely change",
      "Exclusively for Class Components",
      "When a component possesses excessive local states"
    ],
    "correctAnswerIndex": 1,
    "explanation": "React.memo implements a shallow comparative evaluation of props to prevent unnecessary re-renders. It should only be used for visually heavy or computationally expensive UI components whose props seldom change, as overusing it incurs its own comparison cost."
  }
]
